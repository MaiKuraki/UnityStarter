using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json;

namespace CycloneGames.GameplayTags.SourceGenerator
{
    [Generator]
    public class GameplayTagSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new GameplayTagSyntaxReceiver());
            context.RegisterForPostInitialization(ctx =>
            {
                // No post-initialization needed for now, but the hook is here.
            });
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not GameplayTagSyntaxReceiver receiver)
                return;

            var allTags = new HashSet<string>();

            // 1. Get tags from [assembly: GameplayTag] attributes
            foreach (AttributeSyntax attribute in receiver.GameplayTagAttributes)
            {
                string? tagArgument = attribute.ArgumentList?.Arguments.FirstOrDefault()?.ToString().Trim('"');
                if (!string.IsNullOrEmpty(tagArgument))
                {
                    allTags.Add(tagArgument);
                }
            }

            // 2. Get tags from JSON files
            string projectPath = GetProjectPath(context);
            if (!string.IsNullOrEmpty(projectPath))
            {
                string tagsDirectory = Path.Combine(projectPath, "ProjectSettings", "GameplayTags");
                if (Directory.Exists(tagsDirectory))
                {
                    foreach (string file in Directory.GetFiles(tagsDirectory, "*.json"))
                    {
                        string jsonContent = File.ReadAllText(file);
                        try
                        {
                            var tagsFromFile = JsonConvert.DeserializeObject<Dictionary<string, object>>(jsonContent);
                            if (tagsFromFile != null)
                            {
                                foreach (var tagName in tagsFromFile.Keys)
                                {
                                    allTags.Add(tagName);
                                }
                            }
                        }
                        catch (JsonException)
                        {
                            // Log a diagnostic warning for malformed JSON
                        }
                    }
                }
            }
            
            // 3. Get tags from [RegisterGameplayTagsFrom] static classes
            foreach (var attributeData in context.Compilation.Assembly.GetAttributes().Where(ad => ad.AttributeClass?.Name == "RegisterGameplayTagsFromAttribute"))
            {
                if (attributeData.ConstructorArguments.FirstOrDefault().Value is INamedTypeSymbol typeSymbol)
                {
                    foreach (var member in typeSymbol.GetMembers())
                    {
                        if (member is IFieldSymbol field && field.IsConst && field.Type.SpecialType == SpecialType.System_String)
                        {
                            if (field.ConstantValue is string tagValue)
                            {
                                allTags.Add(tagValue);
                            }
                        }
                    }
                }
            }

            TagNode rootTag = new("AllGameplayTags");
            foreach (string tag in allTags.OrderBy(t => t))
            {
                AddTagToHierarchy(rootTag, tag);
            }

            StringBuilder sourceBuilder = new();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("using CycloneGames.GameplayTags.Runtime;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace CycloneGames.GameplayTags.Runtime");
            sourceBuilder.AppendLine("{");

            GenerateTagClasses(sourceBuilder, rootTag, 1);

            sourceBuilder.AppendLine("}");

            context.AddSource("AllGameplayTags.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }
        
        private string GetProjectPath(GeneratorExecutionContext context)
        {
            // A bit of a hack to find the project root from the source generator context
            if (context.Compilation.SyntaxTrees.FirstOrDefault()?.FilePath.Contains("Packages/") == true)
            {
                 // If we're in a package, we need to go up until we find the project root
                var path = new DirectoryInfo(context.Compilation.SyntaxTrees.First().FilePath);
                while (path != null && path.Name != "Packages")
                {
                    path = path.Parent;
                }
                return path?.Parent?.FullName;
            }
            
            // If not in a package, assume it's in Assets
            var assetsDir = context.Compilation.SyntaxTrees.FirstOrDefault(st => st.FilePath.Contains("Assets/"));
            if (assetsDir != null)
            {
                var path = new DirectoryInfo(assetsDir.FilePath);
                while (path != null && path.Name != "Assets")
                {
                    path = path.Parent;
                }
                return path?.Parent?.FullName;
            }

            return null;
        }

        private void AddTagToHierarchy(TagNode root, string tag)
        {
            string[] parts = tag.Split('.');
            TagNode currentNode = root;

            foreach (string part in parts)
            {
                if (string.IsNullOrEmpty(part)) continue;
                
                string sanitizedPart = SanitizeIdentifier(part);
                if (!currentNode.Children.ContainsKey(sanitizedPart))
                {
                    currentNode.Children[sanitizedPart] = new TagNode(sanitizedPart, currentNode);
                }
                currentNode = currentNode.Children[sanitizedPart];
            }
        }
        
        private string SanitizeIdentifier(string name)
        {
            // Replace invalid characters with underscores
            var sb = new StringBuilder(name);
            for (int i = 0; i < sb.Length; i++)
            {
                if (!char.IsLetterOrDigit(sb[i]) && sb[i] != '_')
                {
                    sb[i] = '_';
                }
            }
            // Ensure it doesn't start with a number
            if (char.IsDigit(sb[0]))
            {
                sb.Insert(0, '_');
            }
            return sb.ToString();
        }

        private void GenerateTagClasses(StringBuilder sourceBuilder, TagNode node, int indentLevel)
        {
            string indent = new string(' ', indentLevel * 4);

            if (node.Name == "AllGameplayTags")
                sourceBuilder.AppendLine($"{indent}[System.Obsolete(\"This class is auto-generated. Use its members to access tags safely.\")]");

            sourceBuilder.AppendLine($"{indent}public static partial class {node.Name}");
            sourceBuilder.AppendLine($"{indent}{{");

            if (node.Parent != null) // Not the root node
            {
                string tagPath = string.Join(".", GetTagPath(node));
                sourceBuilder.AppendLine($"{indent}    private static readonly GameplayTag s_Tag = GameplayTagManager.RequestTag(\"{tagPath}\");");
                sourceBuilder.AppendLine($"{indent}    public static GameplayTag Get() => s_Tag;");
                sourceBuilder.AppendLine($"{indent}    public static implicit operator GameplayTag(in {node.Name} tag) => s_Tag;");
            }

            foreach (TagNode childNode in node.Children.Values.OrderBy(n => n.Name))
            {
                GenerateTagClasses(sourceBuilder, childNode, indentLevel + 1);
            }

            sourceBuilder.AppendLine($"{indent}}}");
        }

        private IEnumerable<string> GetTagPath(TagNode node)
        {
            Stack<string> path = new Stack<string>();
            TagNode? current = node;

            while (current != null && current.Parent != null) // Stop at root's children
            {
                // We need the original, unsanitized name for the RequestTag call
                // This requires a more complex TagNode to store both original and sanitized names.
                // For now, we'll assume sanitized name is close enough for hierarchy, but this is a known limitation.
                // A proper implementation would store the original segment. Let's stick to the sanitized one for now.
                path.Push(current.Name);
                current = current.Parent;
            }

            return path;
        }

        private class TagNode
        {
            public string Name { get; }
            public TagNode? Parent { get; set; }
            public Dictionary<string, TagNode> Children { get; }

            public TagNode(string name, TagNode? parent = null)
            {
                Name = name;
                Parent = parent;
                Children = new Dictionary<string, TagNode>();
            }
        }

        private class GameplayTagSyntaxReceiver : ISyntaxReceiver
        {
            public List<AttributeSyntax> GameplayTagAttributes { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is AttributeSyntax attributeSyntax &&
                    attributeSyntax.Name.ToString() == "GameplayTag" &&
                    attributeSyntax.Parent is AttributeListSyntax attributeList &&
                    attributeList.Target?.Identifier.Text == "assembly")
                {
                    GameplayTagAttributes.Add(attributeSyntax);
                }
            }
        }
    }
}
